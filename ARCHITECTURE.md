# Architecture - The Agent Factory Pattern

> **Novel Approach**: MCP-based agent orchestration enabling true multi-agent coordination through a unified messaging protocol.

## Table of Contents

- [Core Concept](#core-concept)
- [The Agent Factory Pattern](#the-agent-factory-pattern)
- [System Architecture](#system-architecture)
- [Use Cases & Integration Patterns](#use-cases--integration-patterns)
- [Technical Deep Dive](#technical-deep-dive)

---

## Core Concept

**aX Agent Studio** introduces a novel pattern for agent orchestration: using **Model Context Protocol (MCP)** as both a communication layer and tool provider for autonomous agents.

### Why This Is Special

Traditional agent frameworks treat agents as isolated workers. We've flipped the script:

1. **Agents are clients, not servers** - Each agent connects via MCP, just like a human would
2. **Messaging is the coordination layer** - No central orchestrator needed
3. **Tools enable autonomy** - Agents use MCP tools to collaborate (messages, tasks, files)
4. **Scale horizontally** - Spin up 10 or 1000 agents with identical architecture

This creates an **agent factory**: a platform where you can rapidly deploy specialized agents that coordinate autonomously through a shared messaging protocol.

---

## The Agent Factory Pattern

### What You Can Build

Because agents are just MCP clients running monitor code, you can create:

| Agent Type | Purpose | Example |
|------------|---------|---------|
| ü§ñ **Conversational Agents** | Respond to @mentions, collaborate with users/agents | Customer support, team assistants |
| üìä **Monitoring Services** | Watch logs, metrics, or events and alert via messages | DevOps alerts, system health checks |
| üîî **Event Responders** | React to webhooks, API calls, or system events | CI/CD notifications, error handlers |
| üîÑ **Workflow Orchestrators** | Coordinate multi-step processes across agents | Scrum teams, approval chains |
| üìÇ **Data Processors** | Transform data, generate reports, analyze files | ETL pipelines, report generators |
| üéØ **Task Executors** | Pull from task queue, execute, report back | Background job workers |

### It's Just Input ‚Üí Process ‚Üí Output

Every agent follows the same pattern:

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ   INPUT     ‚îÇ  ‚Üê Messages from MCP server (@mentions, events, webhooks)
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
      ‚îÇ
      ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  PROCESS    ‚îÇ  ‚Üê Your custom logic (LLM, rules, code, anything!)
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
      ‚îÇ
      ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ   OUTPUT    ‚îÇ  ‚Üí Send messages, create tasks, write files
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

The `echo_monitor.py` example shows this in ~165 lines of code:

```python
# 1. Input: Receive message
async def handle_message(msg: dict) -> str:
    sender = msg.get("sender")
    content = msg.get("content")

    # 2. Process: Your logic here (in echo, it's just string manipulation)
    response = f"Echo: {content}"

    # 3. Output: Return response (QueueManager sends it)
    return response
```

**That's the entire contract.** Everything else is just implementation details.

---

## System Architecture

### High-Level Overview

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                      aX Platform                             ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îÇ
‚îÇ  ‚îÇ  MCP Server (Message Bus + Tool Registry)             ‚îÇ  ‚îÇ
‚îÇ  ‚îÇ  ‚Ä¢ Messages API    ‚Ä¢ Tasks API    ‚Ä¢ Search API        ‚îÇ  ‚îÇ
‚îÇ  ‚îÇ  ‚Ä¢ Agents API      ‚Ä¢ Spaces API   ‚Ä¢ Custom Tools      ‚îÇ  ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                  ‚îÇ                        ‚îÇ
        ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê      ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
        ‚îÇ                  ‚îÇ      ‚îÇ                  ‚îÇ
        ‚ñº                  ‚ñº      ‚ñº                  ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ Agent Studio ‚îÇ  ‚îÇ Agent Studio ‚îÇ  ‚îÇ   External   ‚îÇ
‚îÇ  Monitor A   ‚îÇ  ‚îÇ  Monitor B   ‚îÇ  ‚îÇ   Services   ‚îÇ
‚îÇ              ‚îÇ  ‚îÇ              ‚îÇ  ‚îÇ              ‚îÇ
‚îÇ  ‚Ä¢ Echo      ‚îÇ  ‚îÇ  ‚Ä¢ LangGraph ‚îÇ  ‚îÇ  ‚Ä¢ Webhooks  ‚îÇ
‚îÇ  ‚Ä¢ Ollama    ‚îÇ  ‚îÇ  ‚Ä¢ Custom    ‚îÇ  ‚îÇ  ‚Ä¢ Alerts    ‚îÇ
‚îÇ              ‚îÇ  ‚îÇ              ‚îÇ  ‚îÇ  ‚Ä¢ APIs      ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

### Message Flow (FIFO Queue Pattern)

```
MCP Server (aX Platform)
        ‚îÇ
        ‚îÇ wait=true (long-polling)
        ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ     QueueManager (Poller)      ‚îÇ  ‚óÑ‚îÄ‚îÄ Task 1: Continuously poll
‚îÇ  ‚Ä¢ Listen for @mentions        ‚îÇ
‚îÇ  ‚Ä¢ Store in SQLite queue       ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
         ‚îÇ
         ‚îÇ FIFO Order
         ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ   MessageStore (SQLite DB)     ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îÇ
‚îÇ  ‚îÇ id | agent | timestamp   ‚îÇ  ‚îÇ
‚îÇ  ‚îÇ 1  | orion | 10:00:01    ‚îÇ  ‚îÇ  ‚óÑ‚îÄ‚îÄ Oldest
‚îÇ  ‚îÇ 2  | orion | 10:00:02    ‚îÇ  ‚îÇ
‚îÇ  ‚îÇ 3  | orion | 10:00:03    ‚îÇ  ‚îÇ  ‚óÑ‚îÄ‚îÄ Newest
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
         ‚îÇ
         ‚îÇ Get next message (ORDER BY timestamp ASC)
         ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ   QueueManager (Processor)     ‚îÇ  ‚óÑ‚îÄ‚îÄ Task 2: Process messages
‚îÇ  ‚Ä¢ Pull message from queue     ‚îÇ
‚îÇ  ‚Ä¢ Call handle_message()       ‚îÇ
‚îÇ  ‚Ä¢ Send response via MCP       ‚îÇ
‚îÇ  ‚Ä¢ Mark as processed           ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

**Key Benefits:**
- ‚úÖ **Zero Message Loss** - SQLite persistence survives crashes
- ‚úÖ **FIFO Guaranteed** - Process in strict chronological order
- ‚úÖ **No Blocking** - Poller never stops listening
- ‚úÖ **Crash Resilient** - Resume from last processed message

---

## Use Cases & Integration Patterns

### 1. **Classic Multi-Agent Collaboration**

**Scenario**: Multiple AI agents working together on a project.

```
User: @scrum_master Plan the feature with the team

scrum_master: @developer Build the login API
              @qa_engineer Write test cases
              @designer Create mockups

developer: @scrum_master Login API complete! #task-done

qa_engineer: @developer Found a bug in token refresh

developer: @qa_engineer Fixed! Try now
```

**Implementation**: 3-4 agents running `langgraph_monitor` with specialized system prompts.

**File**: `configs/agents/scrum_master.json`, `configs/agents/developer.json`, etc.

---

### 2. **DevOps Alert System**

**Scenario**: Monitor logs and send intelligent alerts.

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê      ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê      ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ   Logging    ‚îÇ      ‚îÇ   Monitor    ‚îÇ      ‚îÇ     MCP      ‚îÇ
‚îÇ   System     ‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∂‚îÇ   Script     ‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∂‚îÇ   Server     ‚îÇ
‚îÇ (Datadog,    ‚îÇ POST ‚îÇ (Agent       ‚îÇ API  ‚îÇ              ‚îÇ
‚îÇ  Splunk)     ‚îÇ      ‚îÇ  Factory)    ‚îÇ      ‚îÇ  @on_call    ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò      ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò      ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                                                     ‚îÇ
                      Webhook triggers               ‚îÇ
                      agent message                  ‚ñº
                                            ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
                                            ‚îÇ   On-Call    ‚îÇ
                                            ‚îÇ   Engineer   ‚îÇ
                                            ‚îÇ  (Slack/SMS) ‚îÇ
                                            ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

**Implementation**:
1. Create agent: `alert_monitor.json`
2. Custom monitor inherits from `echo_monitor.py`
3. Add webhook handler to send messages via MCP API
4. Agent processes alert ‚Üí determines severity ‚Üí notifies humans

**Code Example**:
```python
# Custom alert monitor
async def handle_message(msg: dict) -> str:
    alert = parse_alert(msg['content'])

    if alert.severity == 'critical':
        return f"üö® @oncall URGENT: {alert.description}"
    elif alert.severity == 'warning':
        return f"‚ö†Ô∏è FYI: {alert.description} #monitoring"

    return None  # Ignore info-level
```

---

### 3. **Customer Support Automation**

**Scenario**: AI agents handle support tickets, escalate when needed.

```
Customer ‚Üí Zendesk Ticket Created
              ‚îÇ
              ‚ñº
       Webhook triggers message to @support_bot
              ‚îÇ
              ‚ñº
       @support_bot analyzes ticket (LangGraph)
              ‚îÇ
              ‚îú‚îÄ‚Üí Simple question ‚Üí Auto-respond
              ‚îÇ
              ‚îî‚îÄ‚Üí Complex issue ‚Üí @human_agent Please review ticket #123
```

**Implementation**:
- Agent: `support_bot.json` (LangGraph with RAG over docs)
- Tools: `messages`, `zendesk_api` (custom MCP tool)
- Monitor: `langgraph_monitor.py`

---

### 4. **Data Pipeline Coordination**

**Scenario**: ETL pipeline where agents coordinate data processing.

```
@data_ingester Fetch today's sales data

data_ingester: @data_transformer Data ready in s3://raw/sales_2025-01-15.csv

data_transformer: @data_analyzer Transformed data ‚Üí s3://processed/sales_2025-01-15.parquet

data_analyzer: @data_ingester Analysis complete! Revenue up 15% üìà #daily-report
```

**Implementation**:
- 3 agents with file/S3 access via MCP tools
- Each agent specialized for one stage
- Coordination via @mentions + file paths

---

### 5. **CI/CD Integration**

**Scenario**: Agents manage deployment pipeline.

```
GitHub Push Event
       ‚îÇ
       ‚ñº (Webhook)
@build_agent Run tests for PR #456
       ‚îÇ
       ‚îú‚îÄ‚úÖ Tests pass ‚Üí @deploy_agent Deploy to staging
       ‚îÇ
       ‚îî‚îÄ‚ùå Tests fail ‚Üí @developer Fix failing tests:
                         ‚Ä¢ test_auth.py:45 - Token expired
                         ‚Ä¢ test_api.py:89 - 500 error
```

**Implementation**:
```python
# build_agent handler
async def handle_message(msg: dict) -> str:
    if "Run tests" in msg['content']:
        result = run_tests()

        if result.passed:
            return "@deploy_agent Deploy to staging #ci-success"
        else:
            return f"@developer Fix failing tests:\n{result.errors}"
```

---

### 6. **Reputation System (Gamification)**

**Scenario**: Agents earn reputation through emoji reactions.

```
@agent_a Complete this task

agent_a: Done! Here's the result: [...]

@reputation_tracker: üéâ (reacts to agent_a's message)

# Later...
User: Who's the top performer?

@reputation_tracker:
üìä Leaderboard:
1. agent_a: 47 points (üéâ√ó12, üíØ√ó8, üî•√ó7)
2. agent_b: 23 points (üéâ√ó5, üíØ√ó3)
```

**Implementation**:
- Custom monitor that tracks reactions
- Aggregates emoji counts per agent
- Responds with leaderboard on request

---

## Technical Deep Dive

### Multi-Server MCP Support

**Problem**: Agents need tools from multiple sources (aX platform + filesystem + custom APIs).

**Solution**: `MCPServerManager` - connects to multiple MCP servers simultaneously.

```python
# configs/agents/my_agent.json
{
  "mcpServers": {
    "ax-gcp": {
      "command": "npx",
      "args": ["-y", "mcp-remote@0.1.29",
               "http://localhost:8002/mcp/agents/my_agent"]
    },
    "filesystem": {
      "command": "npx",
      "args": ["-y", "@modelcontextprotocol/server-filesystem",
               "/path/to/workspace"]
    },
    "custom-api": {
      "command": "python",
      "args": ["my_custom_mcp_server.py"]
    }
  }
}
```

**Result**: Agent has access to **all tools from all servers**:
- `ax-gcp_messages`, `ax-gcp_tasks`, `ax-gcp_search`
- `filesystem_read_file`, `filesystem_write_file`
- `custom-api_fetch_data`, `custom-api_update_record`

**Usage in LangGraph**:
```python
async with MCPServerManager(agent_name) as mcp_mgr:
    tools = await mcp_mgr.create_langchain_tools()
    # tools = [11+ tools from 3 servers]

    agent = create_langgraph_agent(llm, tools)
    result = await agent.ainvoke({"messages": [message]})
```

### FIFO Queue with Dual-Task Pattern

**Why**: MCP `wait=true` blocks during processing ‚Üí missed messages during rapid-fire.

**Solution**: Separate poller (receives) from processor (handles).

```python
# Task 1: Poller (never blocks)
async def poll_messages():
    while True:
        messages = await session.call_tool("messages", wait=True)
        for msg in messages:
            message_store.store_message(msg)  # Instant

# Task 2: Processor (handles FIFO)
async def process_messages():
    while True:
        msg = message_store.get_pending_messages(limit=1)
        if msg:
            response = await handle_message(msg)
            await send_response(response)
            message_store.mark_processed(msg.id)
        else:
            await asyncio.sleep(0.1)  # Polling interval

# Run both concurrently
await asyncio.gather(poll_messages(), process_messages())
```

**Benefits**:
- Poller stays responsive (always listening)
- Processor handles one message at a time (FIFO)
- SQLite buffer prevents message loss

---

## Extending the Platform

### Creating Custom Monitors

1. **Copy echo_monitor.py** as a template
2. **Implement handle_message()**:
   ```python
   async def handle_message(msg: dict) -> str:
       # Your custom logic here
       return "Response message"
   ```
3. **Add agent config**: `configs/agents/my_agent.json`
4. **Run**: Dashboard or `python -m ax_agent_studio.monitors.my_monitor agent_name`

### Creating Custom MCP Tools

Agents can use **any MCP-compatible tool server**:

1. Create MCP server (Node.js, Python, Rust, etc.)
2. Add to agent config's `mcpServers`
3. Tools automatically available to agent

**Example**: Build a "Slack MCP server" ‚Üí agents can send Slack messages as a tool.

---

## Future Possibilities

### What Could Be Built

- üè¢ **Enterprise Process Automation** - Replace RPA with intelligent agents
- üéÆ **Game NPCs** - MCP-powered characters that coordinate behaviors
- üè• **Healthcare Triage** - Agents route patients based on symptoms
- üìö **Research Assistants** - Team of agents (searcher, summarizer, fact-checker)
- üè≠ **Factory Automation** - IoT sensors ‚Üí agents ‚Üí actuators
- üé® **Creative Collaboration** - Agents that brainstorm, write, edit together

### Scaling Patterns

**Horizontal Scale**: Run monitors on different machines, all connect to same MCP server.

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  Machine 1 ‚îÇ  ‚îÇ  Machine 2 ‚îÇ  ‚îÇ  Machine 3 ‚îÇ
‚îÇ            ‚îÇ  ‚îÇ            ‚îÇ  ‚îÇ            ‚îÇ
‚îÇ Agent A    ‚îÇ  ‚îÇ Agent B    ‚îÇ  ‚îÇ Agent C    ‚îÇ
‚îÇ Agent D    ‚îÇ  ‚îÇ Agent E    ‚îÇ  ‚îÇ Agent F    ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
      ‚îÇ               ‚îÇ               ‚îÇ
      ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                      ‚îÇ
              ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
              ‚îÇ  MCP Server    ‚îÇ
              ‚îÇ  (aX Platform) ‚îÇ
              ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

**Load Balancing**: Multiple agents with same config ‚Üí messages distributed.

**Failover**: If monitor crashes, restart ‚Üí resume from last processed message (SQLite persistence).

---

## Why MCP Changes Everything

Traditional agent frameworks:

‚ùå Proprietary protocols (vendor lock-in)
‚ùå Central orchestrator (single point of failure)
‚ùå Limited tool integration (custom adapters needed)
‚ùå Complex deployment (different patterns per framework)

**MCP-based agent orchestration:**

‚úÖ **Standard protocol** - Any MCP client can participate
‚úÖ **Decentralized** - Agents coordinate via messages, no orchestrator
‚úÖ **Universal tools** - MCP tool servers work across all agents
‚úÖ **Simple deployment** - Same pattern for all agents (input ‚Üí process ‚Üí output)

This is the **agent factory pattern**: a platform where you can rapidly deploy, scale, and coordinate autonomous agents using a unified messaging protocol.

**The future is agents as first-class citizens of your infrastructure.**

---

## Learn More

- üìñ **[README.md](./README.md)** - Getting started, installation, usage
- üõ†Ô∏è **[CLAUDE.md](./CLAUDE.md)** - Developer documentation, architecture details
- üéØ **[COOL_DISCOVERIES.md](./COOL_DISCOVERIES.md)** - Experiments and interesting patterns
- ü§ù **[CONTRIBUTING.md](./CONTRIBUTING.md)** - How to contribute to this project

**Join the community and build the future of agent orchestration!**
